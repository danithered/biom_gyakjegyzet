---
title: "Gyakorlati segédanyag Biostatisztika gyakorlathoz"
author: "Vörös Dániel, Radványi Ádám, Könnyű Balázs"
date: "2020/21/2"
output: 
  bookdown::pdf_book:
    includes:
      in_header: "kell.tex"
      before_body: "titlepage.tex"
always_allow_html: yes
toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache=TRUE)
library(knitr)
library(ggplot2)
library(data.tree)
library(plyr)
library(gridExtra)
#library(DiagrammeR)
library(kableExtra)

hook_output <- knit_hooks$get("output")
knit_hooks$set(output = function(x, options) {
  lines <- options$output.lines
  if (is.null(lines)) {
    return(hook_output(x, options))  # pass to default hook
  }
  x <- unlist(strsplit(x, "\n"))
  more <- "..."
  if (length(lines)==1) {        # first n lines
    if (length(x) > lines) {
      # truncate the output, but add ....
      x <- c(head(x, lines), more)
    }
  } else {
    x <- c(more, x[lines], more)
  }
  # paste these lines together
  x <- paste(c(x, ""), collapse = "\n")
  hook_output(x, options)
})

```

<!-- 1. Bevezetés -->
```{r child="fejezetek/bevezetes.Rmd"}
```

<!-- 1. Ora, matematikai alapok -->
```{r child="fejezetek/matalap.Rmd"}
```

<!-- 1. Ora, R alapok -->
```{r child="fejezetek/ralap.Rmd"}
```

<!-- 2. Ora diszkret eloszlasok -->
```{r child="fejezetek/ora2.Rmd"}
```

<!-- 3. Ora folytonos eloszlasok -->
```{r child="fejezetek/ora3.Rmd"}
```


# Adatok beolvasása és ábrázolása (4. óra)

## Mappák

Ezt a fejezetet hagyják ki, akik ismerik a következő fogalmakat: "mappa", "elérési útvonal"!   

A mai operációs rendszerek a háttértáron tárolt fájlokat egy mappastruktúrába rendezik. Ez a mappastruktúra azért létezik, hogy a mi tájékozódásunkat segítse a fájljaink között. Az emberi elme ugyanis szereti hierarchikusan rendezni / rendszerezni a dolgokat. A mappastruktúrában a mappákat mint rendszerező "dobozokat" lehet elképzelni. 

Képzeljük el, hogy van 100 darab legódarabkánk és azt szeretnénk elérni, hogy gyorsan ki tudjuk mindig keresni a megfelelő legódarabot. Ekkor elrakhatjuk a legóinkat úgy is, hogy veszünk két dobozt: az egyikre ráírjuk, hogy "lapos", a másikra pedig, hogy "magas". Azonban a legók nem csak vastagságban térnek el, így a már meglévő dobozokon belül új dobozokat helyezhetünk el a legó egységek számának jelzésére: "1", "2x2", "2x3", stb. De a "vastag", "2x2" -es legók sem egyformák, így rakhatunk újabb dobozokat a kis dobozokon belülre is, mondjuk a színek szerint: "sárga", "szürke", "fehér". Most, hogy van sok dobozunk, elhelyezhetjük a legóinkat, úgy, hogy ha kell egy nagy fehér 2x3-as elem, egyből tudjuk, hogy sorra a "vastag", "2x2" és "fehér" dobozokat kell kinyitnunk. Ezzel a módszerrel sokkal gyorsabban kereshetünk, mintha 100 összekevert eltérő kocka közül kéne kiválogatni a megfelelőt. Persze az is lehet, hogy van egy vastag 1-es elem, aminek különleges hupikék színe van. Ennek nem biztos, hogy érdemes új dobozt nyitni, mert csak egy van belőle, így az dobhatjuk a "vastag" dobozon belüli "1" -es dobozba is. Tehát egy doboz tartalmazhat más dobozokat és legókockákat is egyszerre. A számítógépek mappastruktúráját is így lehet elképzelni.  

Vegyünk egy példa mappastruktúrát:

```{r dirtree, fig.cap="Példa mappastruktúra \\label{dirtree}", echo=FALSE}
dirtree_path <- c(
    "/gyoker/mappaA/mappaAA/file.R", 
    "/gyoker/mappaA/file1.R", 
    "/gyoker/mappaA/file2.R", 
    "/gyoker/mappaB/mappaBA/csor.csv", 
    "/gyoker/mappaB/mappaBA/mappaBAA/file.R", 
    "/gyoker/mappaB/mappaBA/mappaBAB/vaj.csv",
    "/gyoker/mappaB/mappaBA/mappaBAB/asztal.csv"
)
(mytree <- data.tree::as.Node(data.frame(pathString = dirtree_path)))
#plot(mytree)
```

Ebben a következőket vehetjük észre:

  * Azt a mappát, amiben az összes többi mappa és fájl van "gyökér"-nek hívjuk
  * Ugyanazon mappában nem lehet két ugyanolyan nevű fájl
  * Különböző mappákban lehetnek ugyanolyan nevű fájlok
  * Egy fájlt egyértelműen meghatározza a fájl neve és a mappák nevei, amikben van

Elérési útvonalnak nevezzük azokat a karaktersorozatokat, amelyek meghatározzák egy fájl helyét és nevét a mappastruktúrában. Például az előző mappastruktúrában található fájlok elérési útvonalai:

```{r dirtree_list, echo=FALSE}
cat(dirtree_path, sep="\n")
```

Itt a fájlok nevei előtt hierarchikusan a gyökértől kezdve fel vannak sorolva a mappák, amikben vannak. Így pontosan tudjuk milyen mappákat milyen sorrendben kell megnyitni, hogy megtaláljuk a keresett fájlt.

Fontos megjegyezni, hogy például a webcímek is elérési útvonalak. Például a kurzus honlapja: "http://plantsys.elte.hu/drupal/hu/oktatas/biometria" esetén a "biometria" az oldal, amit el akarunk érni, a "http://" rész megmondja a számítógépnek, hogy milyen protokollt használjon az oldal eléréséhez, a "plantsys.elte.hu" a szerver neve, azon belül a "drupal", a "hu" és "oktatas" mappákban van a "biometria" oldal.

## Az **R** munkakönyvtára

Az **R** jó linuxos programként mindig egy adott könyvtárban dolgozik. Alapértelmezettként innen olvas és ide ír fájlokat. Ezt hívjuk munkakönyvtárnak (*working directory*). Ha meg akarjuk tudni melyik ez a könyvtár:

```{r getwd, eval=F}
getwd()
```

```{r getwd_hamis, echo=FALSE}
print("/gyoker/mappaB/mappaBA")
```

Meg is változtathatjuk a *working directory*-t. Ha egy almappát akarunk megtenni munkakönyvtárnak, akkor elég az almappa nevét megadni **szövegként** (*relatív fájlelérési útvonal*: csak egy adott könyvtárszinthez képest adjuk meg a *working directory*-t):

```{r setwd, eval=F}
setwd("mappaBAB") #a "mappaBAB" helyére egy valós mappanevet írjanak!
```

Ellenőrizzük le!

```{r getwd2, eval=F}
getwd()
```

```{r getwd_hamis2, echo=FALSE}
print("/gyoker/mappaB/mappaBA/mappaBAB")
```

Ha nem almappára akarjuk változtatni a munkakönyvtárat, akkor **teljes** (vagy *abszolút*) elérési útvonalat is meg lehet neki adni (ez a *gyökérkönyvtárhoz képest adja meg a fájl helyét*):

```{r setwd2, eval=F}
setwd("/gyoker/mappaB/mappaBA") #ez nem valos eleresi utvonal!
```

```{r getwd3, eval=F}
getwd()
```

```{r getwd_hamis3, echo=FALSE}
print("/gyoker/mappaB/mappaBA")
```

FONTOS: *MS Windows* alatt az elérési útvonalban lévő "\\" perjeleket le kell cserélni "/" perjelre!

Ha *Asztal*-on vagy *Dokumentumok*-ban vannak a fájlok, akkor úgy kell kikeresni az elérési útvonalat, hogy a "C:" gyökérkönyvtárból indultok ki (C:/Users/felhasznalo/stb), nem pedig a gyorsgombbal! 

## Táblázatok beolvasása **R**-ben

A gyakorlat, valamint jövőbeli adatelemzéseitek során legtöbbször szöveges adattáblából kell az adataitokat beolvasni. Ezek (*.txt, .dat, .csv, .tsv*) kiterjesztésűek.

Először is a beolvasandó fájl elérési útvonalát kell megkeresni. Két lehetőség van "OPCIÓ 1" es "OPCIÓ 2", mindenki azt válassza, amelyik számára szimpatikusabb! A jegyzet írói a további fejezetekben az "OPCIÓ 1"-et fogja használni.

### OPCIO 1 - elérési útvonallal - haladó megoldás

Keress ki egy mappát, amiből kényelmesen eléred a fájljaidat!

```{r getwd5, eval=FALSE}
getwd() #megadja, melyik mappabol van inditva az R
```

Ha nem megfelelő a mappa, másikban vannak az adatok:

  * 1. keresd ki a mappa helyét egy fájlböngészővel!
  
  * 2. másold be a `setwd()` függvénybe. Mivel szöveg, kell az idézőjel!
 
```{r setwd3, eval=F}
setwd("/gyoker/mappaB/mappaBA") #ez nem valos eleresi utvonal!
```

  * 3. ellenőrzés `getwd()` függvénnyel!
 
```{r getwd6, eval=FALSE}
getwd() #megadja, melyik mappabol van inditva az R
```

```{r getwd_hamis6, echo=FALSE}
print("/gyoker/mappaB/mappaBA")
utvonal1 <- "/gyoker/mappaB/mappaBA/csor.csv"
```

Két féle elérési útvonalat kell megkülönböztetnünk: relatív és abszolút. Relatív hivatkozás alatt a munkakönyvtárból kiinduló útvonalat értjük. Tehát ha a munkakönyvtár most a "/gyoker/mappaB", akkor a "csor.csv" fájlhoz a relatív elérési útvonal a következő: "mappaBA/csor.csv". Ha viszont a munkakönyvtár a "/gyoker/mappaB/mappaBA", akkor ugyanahhoz a fájlhoz a relatív elérési útvonalam csak ennyi: "csor.csv". A relatív elérési útvonal tehát változik attól függően, hogy mi a munkakönyvtár. Ellenben az abszolút elérés útvonal a gyökérkönyvtárhoz képest adja meg a fájl helyét: "/gyoker/mappaB/mappaBA/csor.csv". Így ez független attól, hogy mi az elérési útvonalam. Az abszolút elérési útvonalat úgy is megkaphatjuk, hogy egy fájlböngészőben kikeressük a megnyitni szándékozott fájlt, kijelöljük és másoljuk (CTRL + C, vagy jobbklikk -> Másolás), majd belemegyünk az **RStudio** valamelyik szöveges felületére, és "beillesztjük" a fájlt. Ekkor egy ehhez hasonló elérési útvonalat kapunk: `"file:///gyoker/mappaB/mappaBA/csor.csv"`. Ez ebben a formában is használható, még Windows esetén is.  
Ha megvan az elérési útvonalunk, akkor `read.table()` függvénnyel tudjuk beolvasni.

```{r filechoose_0, eval=FALSE}
read.table("csor.csv")
#read.table("csor.csv", sep=";", header=TRUE,	dec="." )
```

A `read.table()` függvény további argumentumai is szükségesek, hogy megfelelően beolvassuk a fájlt, ezek a "A táblázat beolvasása" fejezetben lesznek tárgyalva.

### OPCIO 2 - `file.choose()` - kezdő megoldás

A `file.choose()` függvény hatására megnyílik egy új ablak, ami a számítógép fájl rendszerét mutatja (pontosabban az aktuális munkakönyvtárat mutatja). Itt megkereshető a fájl, amivel dolgozni szeretnénk és kimásolja a fájl teljes elérési útvonalát szövegként. *Megjegyzés.* Gyakori, hogy a `file.choose()` hatásár megnyíló új ablak az **RStudio** ablaka mögé kerül.

```{r filechoose_1, eval=FALSE}
utvonal1 <- file.choose()
```

```{r filechoose_2}
utvonal1 # nezzetek meg tenyleg jo fajlra mutat-e!
```

Elmentjük ezt az útvonalat egy változóba. Ez azért célszerű, hogy később ha gond lenne a beolvasással ne kelljen minden alkalommal újra kikeresni a fájlt.

A fájlt ekkor így olvassuk be:

```{r filechoose_3, eval=FALSE}
read.table(utvonal1)
#read.table(utvonal1, sep=";", header=TRUE,	dec="." )
```

Fontos megjegyezni, hogy ekkor nem kell idézőjel az *utvonal1* mellé, hisz az egy változó, ami szöveget tartalmaz, nem pedig szöveg! A `read.table()` függvény további argumentumai is szükségesek, hogy megfelelően beolvassuk a fájlt, ezek a következő fejezetben lesznek tárgyalva. Azonban a következő fejezetet már az "OPCIÓ1" szerint fogjuk tárgyalni, ahol az útvonalat szövegként tesszük be az első argumentumként!

### A táblázat beolvasása

Mielőtt beolvasnánk az adattáblát nézzük meg a fájlunkat egyszerű szövegszerkesztővel. (Windows: fájl kijelöl -> jobbklikk -> Társítás -> Jegyzettömb vagy Notepad++; Linux: ugyanez csak más programokkal, pl. Kate, gedit) Fontos, hogy ne nyissuk meg MS Excel vagy LibreOffice Calc programmal, mert ezek nem fogják megmutatni nekünk azokat a tulajdonságokat, amikre kíváncsiak vagyunk, valamint gyakran átírják magát a fájlt is!

Jegyzeteljük le magunknak a következő adatokat: mező elválasztó jel, decimális karakter, van-e fejléc(\emph{header}).
 
Például, ha van egy ilyen fájlunk:

```{r csorkiir, echo=FALSE, comment=""}
#read.table("csor.csv", sep=";", header=TRUE)
cat(readLines("csor.csv", n=10), sep="\n")
```

akkor:

  * **fejléc**: megnézzük, hogy az első sor más adatokat tartalmaz-e, mint a többi sor, vagyis, hogy az első sorban vannak-e megadva az oszlopok nevei. Ebben az esetben láthatjuk, hogy míg az első sorban csak nevek vannak, addig a másodikban bőven vannak számadatok is, szóval van fejlécünk!
  
  * **mező elválasztó karakter**: a szöveges adattáblákban egy karakterrel szokták elválasztani a különböző mezőket egy soron belül. A fájlok kiterjesztései néha szoktak erre támpontot adni, azonban ez gyakran hamis, tehát mindig meg kell nézni a fájlt magát. Az elválasztó karakter szinte **bármilyen** karakter lehet!!! Ebben az esetben az elválasztó karakter a pontosvessző (**;**). Láthatjuk, hogy minden pontosvessző után egy másfajta adat kezdődik. 
  
  * **decimális karakter**: ha van az adattáblánkban tizedestört, akkor jó tudni, hogy milyen karakterrel választja el az egészrészt és a tizedesrészt. A decimális karakter lehet pont (**.**) vagy vessző (**,**). Ebben az esetben pont.

A `read.table()` függvénnyel beolvassuk és elmentjük a fájlt a `coradat` változóba:

```{r csor_beolvas}
# ahol a sep, dec es header utan behelyettesititek a megfelelo karaktert / logikai erteket
csoradat <- read.table("csor.csv", sep=";", header=TRUE,	dec="." ) 
```

```{r csor_beolvasa2, eval=FALSE}
# ez egyenerteku azzal, ha az egesz eleresi utvonalat helyettesititek be:
csoradat <- read.table("/gyoker/mappaB/mappaBA/csor.csv", sep=";", header=TRUE,	dec="." )
```

Első helyre a beolvasandó fájl elérési útját, a `sep` argumentumban a mező elválasztó karaktert, a `dec` argumentumban a decimális karaktert adjuk meg, míg a `header` logikai argumentum azt adja meg, hogy van-e fejléce az adatoknak (`TRUE`) vagy nincs (`FALSE`).

### Beolvasás ellenőrzése

A beolvasott fájlt mindig ellenőrizzük az `str()` függvény segítségével!! Az `str()` függvény adja a legbővebb információt, de lehet azon kívül a `head()` és a `tail()` függvényeket is használni lásd később.

```{r}
str(csoradat)
```

Itt láthatjuk, hogy a változó ami az adatainkat tartalmazza  `data.frame` típusú, 2600 rekorddal (sorral), és öt mezővel (oszloppal). Ez eddig rendben van. Ha több változót vártunk volna, vagy kevesebbet kaptunk volna, akkor az azt jelenti, hogy nem sikerült megtalálnunk a megfelelő mező szeparátor karaktert!  

Az első változó a *Faj* faktor típusú, elemei pl. "harkalypinty", "harkalypinty_fogs1", stb. Ez jó, ezek szöveges adatok, nem is vártunk volna numerikus változót.

A második változó a *Csorhossz* numerikus változó, melynek értékei tizedestörtek. Ez így szintén jó, de ha ezt faktornak írta volna, az azt jelentette volna, hogy elrontottuk valamelyik argumentum megadását.  

Így végignézzük az `str()` függvény kimenetelét és eldöntjük úgy olvastuk-e be az adattáblát , ahogy szerettük volna.

További hasznos függvények is vannak az adataink megnézésére (a korábban tanult `View()` mellett). Hosszú adatsorok esetén megnézhetjük a táblázat elejét és végét a következő függvényekkel, melyek az első ill. az utolsó pár rekordot írják ki a képernyőre:

```{r}
head(csoradat) # tablazat elso par sora
```

```{r}
tail(csoradat) # tablazat utolso par sora
```

## Táblázatok kiírása **R**-ben

Az **R** belső adatstruktúráit ki is lehet írni szöveg alapú táblázatokba. Ezt a `write.table()` paranccsal tudjuk megtenni, ahol az argumentumok:

  * a kiírandó változó neve
  * **file**: a létrehozandó fájl neve (relatív vagy abszolút elérési útvonal)
  * **sep**: mező elválasztó karakter
  * **dec**: decimális karakter
  * **row.names** és **col.names**: ha `TRUE`, akkor kiírja a sor-, illetve az oszlopneveket a fájlba
  * **quote**: ha `TRUE`, akkor idézőjelbe teszi a szöveg és a faktor típusú cellák tartalmát

```{r write_table_1, eval=FALSE}
write.table(csoradat, file="ujcsor.txt", sep="\t", dec=".")
```

## Adatok szűrése és rendezése

Ha adatokkal dolgozunk gyakran futunk olyan problémába, hogy nem minden az adattáblánkban lévő adattal akarunk dolgozni. Ekkor le kell válogatnunk a számunkra szükséges adatokat, hogy a statisztikai / adatábrázolási függvényeink megfelelően tudjanak dolgozni. Ezt nevezzük szűrésnek. Néha előfordul, hogy meg kell változtatni a táblázatunk adattípusait, esetleg újrarendezni az adatokat, hogy elemezni tudjuk. Ebbe sok minden beletartozhat a tábla rekonstrukciójától az oszlopok típusának megváltoztatásáig.  
A fejezetben a következő adattáblát fogjuk használni:

```{r szures_adatletrehozas}

kutyus <- data.frame(
  nev=c("Bloki", "Kutya", "Fifi", "Rex", "Vakarcs", "Fifi", "Jumurdzsak", "Hogolyo")
  , nem=c("N", "H", "H", "N", "N", "H", "N", "N")
  , mintazat=c(1,1,2,3,4,2,3,4)
  , marmagassag=c(22.5, 41.2, 33.6,10.6, 54.8, 35.1, 30.1,29.1)
  , kor=c(1,5,6,NA,5,7,3,2)
  , ivartalanitott=c(FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, NA, TRUE)
)

```


```{r szures_adatletrehozas_kable, echo=FALSE}
kable(kutyus)
```


### Adatok szűrése indexeléssel

Sokszor ez elemezni kívánt adatokat nagy adatfájlokban tárolják, melyekben több adat van, mint amennyit mi egy adatelemzés során felhasználni szeretnénk. Ekkor az megfelelő statisztikai elemzéshez az adatainkat szűrni kell. Ebben a fejezetben részletesen végigvesszük hogyan célszerű csinálni, majd a fejezet végén röviden összefoglaljuk.  

Az indexelés bemutatásra került a korábbi fejezetekben. Egy kis ismétlés azonban sosem árt. *Matrix* és *data.frame* indexelése során a táblázat neve után indexelő karaktereket (**[ ]**) írunk, amit egy vesszővel választunk el (`valtozonev[ , ]`). A vessző elé az indexelendő sorszámot, míg utána az indexelendő oszlopszámot írjuk: `valtozonev[ sorszam , oszlopszam ]`. Ha a sor- és oszlopszámot üresen hagyjuk, akkor az **R** úgy veszi, mintha mindent ki akarnánk íratni.

```{r}
kutyus[ , ]
```

Ha arra vagyunk kíváncsiak, hogy, a 2. számú kutyának milyen adatai vannak, akkor a vessző elé beírjuk a 2-es számot:

```{r}
kutyus[2, ]
```

Ha arra vagyunk kíváncsiak, hogy a másodiktól a negyedik rekordig milyen adatai vannak a kutyáknak, akkor vektorként tesszük bele:

```{r}
kutyus[2:4, ]
kutyus[c(2,3,4), ] #egyenertekuek
```

Ha pedig arra vagyunk kíváncsiak, hogy a második kivételével, milyen adatok vannak a rekordban, akkor azt egy mínusz (**-**) előjellel jelezzük.

```{r}
kutyus[-2, ]
```

Logikai értékekkel is jelezhetjük melyik sorok adatait akarjuk látni. Ez a logikai vektor (`FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE`) például azt jelenti, hogy csak a 2,. 3. és 4. sort írja ki, vagyis ahol `TRUE` van.

```{r}
kutyus[c(FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE), ]
```

Oszlopok esetén ennél több lehetőségünk van (legalábbis, ha *data.frame*-ről beszélünk). Példaként vegyük ki az első oszlop adatait! Ezt megtehetjük az oszlop számának jelzésével, vagy az oszlop nevével is.

```{r}
kutyus[ , 1]
kutyus[ , "nev"]
kutyus$nev
```

Így ha a 2., 3. és 4. kutya nevére vagyunk kíváncsiak, akkor az előzőkből összetéve:

```{r}
kutyus[2:4, 1]
kutyus[2:4, "nev"]
```

Ha arra vagyunk kíváncsiak, hogy melyik kutya nőstény, akkor azt logikai lekérdezéssel kaphatjuk meg:

```{r}
kutyus$nem == "N"
```

Számoljuk is meg, hány!

```{r}
sum(kutyus$nem == "N")
```

Ugyanígy rákereshetünk arra is, hogy mely kutyák marmagassága nagyobb, mint 30 cm.

```{r}
kutyus$marmagassag > 30
```

Megszámoljuk: 

```{r}
sum(kutyus$marmagassag > 30)
```

Logikai műveletekkel pedig megnézhetjük melyik 1-es mintázatú kutyák marmagassága nagyobb mint 30 cm. Ehhez először is tudnunk kell melyikük nőstények, aztán tudnunk kell melyik nagyobb mint 30 cm és azokat kell látnunk, amikben ez a két tulajdonság egyszerre megvan. Ezt a logikai *ÉS* művelettel tudjuk megtenni.

```{r}
kutyus$mintazat == 1 & kutyus$marmagassag > 30
```

Számoljuk meg, hány ilyen kutya van!

```{r}
sum(kutyus$mintazat == 1 & kutyus$marmagassag > 30)
```

Láthatjuk, hogy csak egy olyan kutya van, amelyiknek 1-es számú mintázata van és magas is egyszerre. Azonban jó lenne tudni ennek a kutyának az adatait is! Ehhez az indexelést kell segítségül hívni. Ezt úgy tudjuk megtenni, hogy van egy logikai vektorunk a logikai lekérdezés eredményeként, tehát ezt berakhatjuk a sorszámok helyére!

```{r}
kutyus$mintazat == 1 & kutyus$marmagassag > 30
kutyus[kutyus$mintazat == 1 & kutyus$marmagassag > 30 , ]
```

Ha minden egyéb eredményre vagyunk kíváncsiak, tehát minden olyan kutyára, aminek nem 1-es számú mintázata van, vagy az van, de alacsonyabb mint 30 cm, akkor a logikai **NEM** operátort használjuk.

```{r}
! (kutyus$mintazat == 1 & kutyus$marmagassag > 30)
kutyus[! (kutyus$mintazat == 1 & kutyus$marmagassag > 30) , ]
```

Visszatérve a 30 cm-nél magasabb 1-es számú mintázatú kutyákra, tegyük fel, hogy minket csak ennek a kutyának a neve érdekel. Ekkor berakjuk a megfelelő oszlopnevet az indexelő operátorba, a vessző után.

```{r}
kutyus[kutyus$mintazat == 1 & kutyus$marmagassag > 30 , "nev"]
```

Ha viszont a neve és a kora is érdekel:

```{r}
kutyus[kutyus$mintazat == 1 & kutyus$marmagassag > 30 , c("nev", "kor") ]
```

Előfordulhat az is, hogy egy faktor elemei közül nem csak egyre vagyunk kíváncsiak, hanem egyszerre többre is. Például, ha nem csak ez 1-es mintázatú kutyák érdekelnek, hanem a hármasok is. Ezt egyrészt megcsinálhatjuk a *logikai vagy* operátorral (**|**)

```{r}
kutyus$mintazat == 1 | kutyus$mintazat == 3
```

Ekkor felsoroljuk az eseteket amik érdekelnek és elválasztjuk őket a *logikai vagy* operátorral. Az eredmény az lett, hogy egyszerre látjuk azokat amiknek 1-es vagy 3-as mintázatuk van.  
Sok kondíció esetén viszont belátható módon ez kényelmetlen megoldás, mert sok-sok kondíciót kell beírni és előbb-utóbb elveszünk a sok kódban. Ezért használhatjuk az *eleme-e* operátort (**%in%**)! Így az előző kóddal egyenértékű lesz ez:

```{r}
kutyus$mintazat %in% c(1, 3)
```

Tehát itt az történt, hogy minden sor `$mintazat` adatára megkérdeztük, hogy eleme-e az ${1, 3}$ halmaznak.

Nézzük meg ezen kutyák adatait!

```{r}
kutyus[kutyus$mintazat %in% c(1, 3), ]
```

Most már csak be kell írnunk a többi feltételt (és legyen 30 cm-nél magasabb) valamint, hogy mely adatokra vagyunk kíváncsiak (név és kor)!

```{r}
kutyus[kutyus$mintazat %in% c(1, 3) & kutyus$marmagassag > 30, c("nev", "kor")]
```

**Összefoglalva:** ha adatbázisban szűrni akarunk, leírjuk az adatbázis nevét, majd utána az indexelő operátorokat, elválasztva a vesszővel (`valtozonev[ , ]`). A vessző elé beírjuk, hogy mely sorokra vagyunk kíváncsi, utána pedig, hogy mely oszlopokra/mezőkre (`valtozonev[ sor , oszlop ]`). A sorokat logikai lekérdezésekkel (**==, !=, <, > <=, >=, %in%**) adjuk meg, melyeket logikai operátorokkal köthetünk össze (**&, |, !**). A kívánt oszlopokat pedig a nevükkel vagy sorszámukkal adjuk meg (ha többre vagyunk kíváncsiak, természetesen vektorként!).

### Adatok rendezése

Sok esetben az adatbevitelt végző személy úgy adja meg az adatokat, hogy a csoport nem külön változóként van megadva, hanem az oszlop száma jelöli. Ilyen az *asztal.csv* adatbázis is.

```{r}
asztal <- read.table("asztal.csv", sep="_", dec=",", header=TRUE)
str(asztal)
```

```{r show_asztal, echo=FALSE, fig.cap="Az asztal.csv fájl első pár sora"}
kable(head(asztal))
```

Ez az adatformátum sok esetben nehezíti az adatok elemzését. Erre használható a `stack()` parancs, ami átalakítja nekünk az adatbázist könnyebben kezelhető formába. Fontos, hogy csak akkor használjuk ezt a függvényt, ha tényleg szükségünk van rá!

```{r}
asztal2 <- stack(asztal)
str(asztal2)
```


```{r show_asztal2, echo=FALSE, fig.cap="Az asztal2 data.frame pár középső sora"}
kable(asztal2[(nrow(asztal2)*0.4):(nrow(asztal2)*0.6),])
```

### Oszloptípusok megváltoztatása

Bizonyos adatelemzési módszerek megkövetelik, hogy egy *data.frame* oszlopai megfelelő formátumúak legyenek. A különböző formátumok:

  * *int* (*integer*) és *num* (*numeric*): akkor használjuk, ha a változót arány-, intervallum skálás adatként vagy rangként akarjuk kezelni. Ezzel találkozunk a legtöbbet.
  * *logi* (*logical*): logikai adatok: igen (*TRUE*) - nem (*FLASE*) formában.
  * *character*: csak akkor használjuk, ha karakterműveleteket akarunk az adott mezővel végezni, vagy ki akarjuk íratni. Így ez a statisztikai elemzések során legritkábban használt adattípus.
  * *factor*: ha az adat egy nominális skálájú változó, mely csoportba való tartozást jelöl. Vigyázni kell vele, mert gyakran keveredik az előző kategóriákkal, gondot okozva az adatelemzésben.

Az oszlopok típusait az `str()` paranccsal célszerű ellenőrizni.

```{r}
str(kutyus)
```

A *kutyus* adatbázisban a *nev* és a *nem* szerepel faktorként. Ez jól is van, nem akarjuk ezeket számként kezelni. Esetleg elgondolkozhatunk azon, hogy a kutya neve szöveg is lehetne.  
A *marmagassag* és a *kor* számként vannak tárolva, ami jó is, mivel valószínűleg számként fogunk vele számolni.  
Az *ivartalanitott* oszlop logikai értékeket tartalmaz, ezt is lehet mint csoportmegadást (*factor*-ként) használni például az ivartalanított kutyák vizsgálatból való kizárására. 
A *mintazat* oszlop típusa *num*. Ez nem biztos, hogy jó, tudni kell mit jelölnek a számok. Ha mondjuk foltok számát a szemben, akkor valahogy talán lehet értelme mint számot kezelni, viszont ha a mérést végző személy csak sorszámokkal jelölte a különböző mintázatokat (pl. 1 = dalmata, 2 = foltos, stb.), akkor mint *factor* lehet csak kezelni!!  

Alakítsuk át az oszloptípusokat. Ezt az `as.factor()`, `as.numeric()`, `as.integer()`, `as.character()` és `as.logical()` függvények segítségével tudjuk megtenni. Először ki kell választanunk a megváltoztatandó oszlopot, majd felülírjuk ugyanennek az oszlopnak az előző függvényekkel átalakított másával.  
Először is, alakítsuk át a *nev* oszlopot karakter típusúvá!

```{r}
kutyus$nev <- as.character(kutyus$nev)
str(kutyus)
```

Láthatjuk, csak a *nev* oszlop lett most karakter, a többi maradt az eredeti. Feltételezve, hogy a *mintazat* oszlopban csak számmal jelölt nominális kategóriák vannak, alakítsuk át faktorrá!

```{r}
kutyus$mintazat <- as.factor(kutyus$mintazat)
str(kutyus)
```

Ha közben esetleg kiderülne, hogy a *mintazat*-ban a számok értéke jelentéssel bír, visszaalakíthatjuk.

```{r}
kutyus$mintazat <- as.numeric(kutyus$mintazat)
str(kutyus)
```

### Hiányzó adatok kezelése

Van, hogy nem minden cellában szerepel adat, pl. mert a vizsgálatot nem lehetett elvégezni, vagy mert elveszett az adat. Az ilyen cellákat *NA*-val jelöljük meg. 
Hiányzó adatok felderítésre több lehetőség is kínálkozik

* \texttt{summary()} függvény minden változóra kiszámol bizonyos statisztikai mérőszámokat (\emph{átlagot, mediánt, kvartiliseket, min.}, és \emph{max.}, lásd később) és feltünteti a hiányzó adatok számát

```{r}
summary(kutyus)
```

* \texttt{which()+is.na()} amellyel konkrétan megkereshető hol van a hiányzó adat. Ez akkor lehet hasznos ha kiderül, hogy az adat valójában nem is hiányzik, csak valamit rosszul rögzítettünk

```{r NA2, echo = TRUE, include = TRUE, tidy = TRUE, eval = TRUE}
index <- which(is.na(kutyus)==TRUE, arr.ind = TRUE)
index
kutyus[index]
```

az \texttt{is.na()} minden változótól \'\'megkérdezi, hogy hiányzó adat-e\'\' ha igen akkor az érték \texttt{TRUE}, ha nem akkor \texttt{FALSE}. Ezt lehet felhasználni, a \texttt{which()} függvény segítségével, hogy beazonosítsuk az adatbázisban az NA-k pontos helyét. Érdemes \texttt{arr.ind = TRUE} opciót alkalmazni, mely kigyűjti az `NA` pontos sor és oszlop index értékét. Elmentjük a hiányzó adat pontos elhelyezkedését egy változóba (\texttt{index}).

Azt kell eldönteni, hogy az elemzés során csak azt az egy hiányzó adatot nem használjuk fel, vagy kihagyjuk az elemzésből az egész rekordot (sort). Az előbbire jó megoldás a számos függvény argumentum listájában megtalálható `na.rm` opció. Ilyen például a `sum()` függvény. Alapesetben ha `NA` van az argumentumok közt, a visszatérési értéke `NA` lesz.

```{r}
sum(2,3,4,NA,6)
```

Ha viszont az `na.rm = TRUE` -t beállítjuk, egyszerűen kiveszi a számolásból az *NA*-kat.

```{r}
sum(2,3,4,NA,6, na.rm = TRUE)
sum(kutyus$kor) #masik pelda
sum(kutyus$kor, na.rm = TRUE)
```

Az utóbbira megoldást az  `na.omit()` és `complete.cases()` függvények jelentik. Az `na.omit()` kidobálja az adattáblából a hiányos rekordokat. Vigyázat, ez a függvény minden olyan sort töröl, amiben `NA` van! A `complete.cases()` egy olyan logikai vektorral tér vissza amelyben a teljes rekordot `TRUE`, az egy vagy több hiányzó adatot tartalmazó rekordot `FALSE` jelöli. Ha ezt tesszük meg a változó sorindexének akkor csak a teljes rekordokat írja ki változóba/képernyőre. 

```{r}
str(kutyus)
kutyus2 <- na.omit(kutyus)
str(kutyus2)
```

```{r show_kutyus_na.omit , echo=FALSE}
kable(kutyus2)
```

```{r}
kutyus3 <- kutyus[complete.cases(kutyus),]
str(kutyus3)
```

Alkalmazhatunk logikai lekérdezést is, ha csak azokat a sorokat akarjuk kivenni a vizsgálatból, melyeknek csak egy bizonyos oszlopában van *NA*. Az `is.na()` megmondja minden egyes értékre, hogy `NA`-e? Ha ezt párosítjuk a *logikai nem* operátorral (**!**), akkor megkapjuk azokat az elemeket, melyek *NA*-k.

```{r}
is.na( c(2,4,NA,0) )
!is.na( c(2,4,NA,0) )
```

Ugyan ez kutya koradatokkal:

```{r}
kutyus$kor
is.na(kutyus$kor)
!is.na(kutyus$kor)
```

Erre már csak szűrni kell.

```{r}
kutyus_no_NA_in_kor <- kutyus[!is.na(kutyus$kor), ]
str(kutyus_no_NA_in_kor)
```

```{r show_kutyus_no_NA_in_kor, echo=FALSE}
kable(kutyus_no_NA_in_kor)
```

## Alap adatábrázolás

Az **R** alapcsomagjai elegendőek ahhoz, hogy a kurzus során szükséges ábrákat létre tudjuk hozni. **RStudio**-ban pedig a készített ábráink a jobb oldali **Plots** panelban fognak feltűnni alapértelmezetten (szóval nem kell definiálni grafikus eszközt).

### A *plot()* függvény használata

A `plot()` függvény egy általános adatábrázoló függvény. Viselkedése attól függ, hogy milyen adatokat adunk meg argumentumaként, de leggyakrabban pont- vagy vonaldiagram rajzolásához használjuk. Ha egyetlen számsort adunk meg változóként, akkor a számsor tagjait fogja sorban ábrázolni, *X* tengelyen azt, hogy hányadik a számsorban, *Y* tengelyen a szám számértékét. Ezt viszonylag ritkán szeretnénk ábrázolni, a jegyzetben azért van bent, hogy tudjuk mi történt, ha ilyesmit látunk.

```{r}
x <- c(1,2,3,2,1,1)
plot(x)
```

Ha két vektort adunk meg neki változóként, akkor pontokként ábrázolja őket, úgy hogy az első argumentumból hívja be az *X* koordinátákat, míg a másodikból az *Y* koordinátákat.

```{r myfirstplot, fig.cap="Pontdiagram"}
x <- 1:10
y <- sqrt(1:10)
x
y
plot(x, y)
```

Ezzel egyenértékű, ha beírjuk a `y~x` kifejezést a függvény első argumentumaként, mely azt jelöli, hogy *y függvénye x-nek*. A hullámjelet *tilde*-nek is hívják.

```{r eval=FALSE}
plot(y ~ x)
```

Ha beleírjuk az `x` és az `y` helyére a számokat, akkor is ezt fogjuk kapni, csak a tengelyfeliratok változnak meg.

```{r myfirstplot_short, fig.cap="Pontdiagram a vektorok közvetlen megadásával"}
plot(1:10, sqrt(1:10))
```

Megadhatunk címet és alcímet az ábránknak a `main` és `sub` argumentumokkal.

```{r, myfirstplot_cimek, fig.cap="Pontdiagram címmel és alcímmel"}
plot(x, y
     , main = "Ez egy cim"
     , sub = "negyzetgyok"
)
```

Testreszabhatjuk a tengelyfeliratokat az `xlab` és `ylab` argumentumokkal.

```{r, myfirstplot_tfelirat, fig.cap="Pontdiagram címmel, alcímmel és tengelyfeliratokkal"}
plot(x, y
     , main = "Ez egy cim"
     , sub = "negyzetgyok"
     , xlab = "x tengely"
     , ylab = "y tengely"
)
```

A `type` argumentummal megadhatjuk, hogy milyen ábrázolási módot szeretnénk:

  * "p": pontdiagram, ez az alapértelmezett
  * "l": vonaldiagram
  * "b": pont és vonaldiagram is (**b**oth), a pontok nincsenek a vonallal áthúzva
  * "c": az előző típus vonalai kizárólag
  * "o": pont és vonaldiagram is, a pontok át vannak húzva a vonallal
  * "h": a pontokat oszlopok jelzik az *X* tengely felől
  
```{r myfirstplot_l, fig.cap="Vonaldiagram"}
plot(x, y, type="l")
```

```{r myfirstplot_b, fig.cap="Vonal- és pontdiagram, nem metszik egymást"}
plot(x, y, type="b")
```

```{r myfirstplot_c, fig.cap="Vonaldiagram, a pontoknál ki van hagyva a vonal"}
plot(x, y, type="c")
```

```{r myfirstplot_o, fig.cap="Vonal- és pontdiagram, a pontokon átmegy a vonal"}
plot(x, y, type="o")
```

```{r myfirstplot_h, fig.cap="Oszlopdiagram szerű ábrázolás"}
plot(x, y, type="h")
```

Ha szeretnénk egyéb pontokat is hozzáadni a már létező ábránkhoz, akkor a `points()` függvényt használhatjuk, ami a `plot()` függvényhez hasonlóan működik, azzal a kivétellel, hogy egy már előzőleg létező ábrára rajzol.

```{r, myfirstplot_points, fig.cap="Pontdiagram hozzáadott pontokkal"}
z <- (1:10)^(1/3)
z
plot(x, y)
points(x, z)
```

Hasonlóképpen hozzáadhatunk vonalakat is a `lines()` függvénnyel.

```{r, myfirstplot_lines, fig.cap="Pontdiagram hozzáadott vonalakkal"}
z <- (1:10)^(1/3)
z
plot(x, y)
lines(x, z)
```

Az **R** alap grafikai függvényei az első plottolási parancsban lévő adatokhoz igazítják az ábrázolt területet. Ezt azonban meg lehet változtatni az `xlim` és `ylim` argumentumokkal. Ezeknek egy két elemből álló numerikus vektort kell megadni, ami meghatározza, hogy mettől meddig tartson az ábrázolandó terület az *X* és *Y* tengelyen.

```{r myfirstplot_lim, fig.cap="Pontdiagram beállított plotterülettel"}
plot(x, y
     , xlim = c(2, 8) # x tengely minimuma es maximuma
     , ylim = c(0, 4) # y tengely minimuma es maximuma
     )
```

A tengelyek logaritmikus ábrázolása akkor hasznos, ha valamiről úgy gondoljuk, hogy nagyságrendű megváltozása a fontos. Tehát nem az additív távolságok a lényegesek (pl. $x_1$ 2-vel nagyobb, mint $x_2$), hanem a multiplikatív különbségek (pl. $x_1$ 100-szor nagyobb, mint $x_2$). Mindig mérlegeljük, hogy van-e biológiai relevanciája a tengelyek logaritmizálásának! A logaritmizálást a `log` argumentummal tudjuk beállítani: értéke `"xy"`, ha mindkét tengelyt, `"x"`, ha az x és `"y"`, ha az y tengelyt logaritmizáljuk. (Régi **R** verziókban a tengelyeket logaritmizálni sorra a `xlog=TRUE` és `ylog=TRUE` argumentumokkal lehetett.)

```{r myfirstplot_log, fig.cap="Pontdiagram logaritmizált x és y tengelyekkel"}
plot(x, y, log="xy")
```

### Argumentumok

A plottolás és egyéb grafikus kimenetelek argumentumait a `par()` függvénnyel érhetjük el és módosíthatjuk. Ha valamit állítani szeretnénk a plotunkon, akkor érdemes lefuttatni a `?par` parancsot és a help-ből kikeresni a számunkra fontos argumentumot a különböző beállítási lehetőségek hosszú listájából. Ebben a fejezetben csak a fontosabbakat fogjuk tárgyalni.

Az argumentum alapértelmezett beállításait úgy tudjuk elérni, hogy vagy lefuttatjuk a `par()` parancsot argumentum nélkül és kikeressük a listából az egyes paramétereket, vagy beírjuk a argumentum nevét a függvénybe. Például:

```{r}
par("col")
```

Átállítani úgy tudjuk, hogy argumentumnak írjuk be a paramétert a `par()` függvénybe és értéket adunk neki. Ha át akarjuk állítani például az ábrázolás színét pirosra, akkor:

```{r myfirstplot_par, fig.cap="Pontdiagram ha az alapértelmezett szín a vörös"}
par(col="red")
plot(x, y)
plot(x, y, col="black")
```

Innentől az összes ábrázolás alapértelmezetten piros lesz, amíg meg nem változtatjuk újra. Azonban az alapértelmezettől eltérhetünk, ha az ábrázoló függvényben megadjuk.  
A legtöbbször használt paraméterek:

  * `col`: az ábrázolás színe
  * `pch`: a pontok alakja
  * `lty`: vonalak típusa
  * `lwd`: vonalak vastagsága
  * `cex`, `cex.axis`, `cex.lab`: a karakterek / tengelycímkék / tengelycímek mérete
  * `las`: a tengelycímkék iránya
  * `mar`: margók mérete
  
A színeket megadhatjuk RGB kódokként is meg színnevekkel is. A használható színneveket így listázhatjuk:

```{r list_colors, output.lines=10}
colors()
```

Ha több színt akarunk megadni, akkor vektorként tegyük. Ha elfogytak a megadott színek, az **R** szekvenciálisan újrahasznosítja a vektort, az elejétől kezdve.

```{r myfirstplot_col3, fig.cap="Pontdiagram színezett pontokkal"}
plot(x, y
     , col = c("purple", "tomato", "navy")
     )
```

A különböző pontalakokat a `pch` (point character) paraméterrel lehet megadni. Ez lehet egy szám (mely különböző karaktereket jelöl) vagy egy karakter is (ebben az esetben maga a karakter kerül kiírásra). Vigyázzunk, hogy egy vektornak csak egyfajta elemei lehetnek, így egyszerre csak egyik módszer használható! Az alap karaktereket a `?points` help oldalon lehet kikeresni egy táblázatból. A színekhez hasonlóan itt is több karaktert lehet megadni, melyeket az **R** újrahasznosíthat. 

```{r myfirstplot_pch, fig.cap="Pontdiagram, személyre szabott pontokkal"}
plot(x, y
     , pch = c(5, 19, 15)
     )
points(x, z
       , pch = c(1, "a", "@")
       )
```

Vonalak típusát (`lty`, azaz linetype) is megadhatjuk számokkal, vagy karakterekkel: 0 = "blank" (üres), 1 = solid (folytonos), 2 = "dashed" (szaggatott), 3 = "dotted" (pontozott), 4 = "dotdash" (pontos és szaggatott), 5 = "longdash" (hosszú szaggatott), 6 = "twodash" (pontos és szaggatott). A vonalak vastagságát (`lwd`, azaz line width) pedig számmal adhatjuk meg. A vonalakat is lehet színezni a `col` paraméterrel.

```{r}
plot(x, y
     , type = "l"
     , lty = 3 # type of line
     , col = "violet" # color of line
     , lwd = 2 # width of line
     )
lines(x, z
      , lty = "dotted" # also type of line
      , lwd = 3
      )
```

A `cex`-el beállíthatjuk a karaktereink nagyságát. A `las` paraméter egy 0 és 3 közti szám, ami megadja, hogy állnak a tengelyek címkéi. Leggyakrabban a `las=1` opciót használják, ami minden feliratot horizontálisba fordít.

```{r, myfirstplot_cex, fig.cap="Pontdiagram megnövelt karakter és tengelycímke méretekkel, horizontális tengelycímkékkel"}
plot(x, y
     , cex = 3
     , cex.axis=2
     , las = 1
     )
```

A margók méretének megváltoztatásával a plotterület melletti sáv nagyságát változtathatjuk. Érdemes megjegyezni az eredeti beállítását.

```{r}
mar_orig <- par("mar")
mar_orig
```

Megváltoztatni a `par()` függvénnyel tudjuk. Értéke egy négy tagú numerikus vektor, melynek elemei sorra megmutatják az alsó / bal / felső / jobb oldali margók méretét.

```{r, myfirstplot_mar, fig.cap="Pontdiagram egyéni margókkal"}
par(mar = c(1,1,0,3) )
plot(x, y)
par(mar = mar_orig)
```

### Osztott ábra

Ha egy ábraterületen több ábrát szeretnénk lerajzolni, akkor először el kell döntenünk, hogy hány sorba és hány oszlopba akarjuk. Ezután az `mfrow = c(sor, oszlop)` argumentummal beállítjuk, hogy mekkorára osztjuk a plotterületet. Az argumentum bementi értéke egy két elemből álló numerikus vektor, mely elemek sorra megadják, hogy hány sorba és hány oszlopba szeretnénk ábrázolni. Ezután kiadjuk a megfelelő mennyiségű plot parancsot. A plotok helyei sor szerint töltődnek fel. Ha utána újból egy ábra / egy ábraterületen szeretnénk ábrázolni, akkor vissza is kell állítanunk az argumentumot eredeti állapotába: `mfrow = c(1, 1)`. 

```{r fig.cap="Osztott ábra"}
par(mfrow=c(3,2)) # 3 sor es 2 oszlop
plot(x,y
     , main="Elso plot"
     )
plot(x,y
     , main="Masodik plot"
     , log="x"
     )
plot(x,y
     , main="Harmadik plot"
     , log="y"
     )
plot(x,y
     , main="Negyedik plot"
     , log="xy"
     )
plot(log(x),log(y)
     , main="Otodik plot"
     )
plot(x,y
     , main="Hatodik plot"
     , type="l"
     , las=1
     )
par(mfrow=c(1,1)) # visszaallitjuk eredeti abrazolasra
```

### Eloszlások szemléltetése

Először is olvassunk be adatbázisokat, melyeket a példákban bemutatunk!

```{r huntbeolvas}
hunt <- read.table("cells_huntington.dat", sep="\t", header=TRUE, dec=",")
str(hunt)

beka <- read.table("beka.csv", sep=",", header=TRUE, dec=".")
str(beka)
```

A \texttt{hunt} adattáblát szűrjük meg, hogy csak a "TD_MPS1.3" kultúrából származó primer vezikulák kerületadatait lássuk! 

```{r huntszures_1, output.lines=10}
hunt[hunt$vesicle.type == "Prim", ] # csak a primer vezikulak
hunt[hunt$Cell.culture == "TD_MPS1.3", ] # csak a TD_MPS1.3 kulturabol szarmazo vezikulak
# csak azok a primer vezikulak melyek a TD_MPS1.3 kulturabol szarmaznak
hunt[hunt$vesicle.type == "Prim" & hunt$Cell.culture == "TD_MPS1.3", ] 
hunt[ , "Perimeter..nm."] # az adatbazis vezikula kerulet adatai

# csak a vezikula adatai azoknak a primer vezikulaknak melyek a TD_MPS1.3 kulturabol szarmaznak
hunt[hunt$vesicle.type == "Prim" & hunt$Cell.culture == "TD_MPS1.3", "Perimeter..nm."]

# az utobbival egyenerteku:
# ez azert van mert a "Perimeter..nm." a hatodik oszlop neve. 
#Vagyis az oszlop neveket behelyettesithetjuk azzal, hogy hanyadik oszlop!!!
hunt[hunt$vesicle.type == "Prim" & hunt$Cell.culture == "TD_MPS1.3", 6]

```

Mentsük el ezeket a vezikula adatokat egy változóba!

```{r}
vezik <- hunt[hunt$vesicle.type == "Prim" & hunt$Cell.culture == "TD_MPS1.3", 6]
str(vezik)
vezik
```

Ábrázoljuk ezeknek az adatoknak az eloszlását! Ezt legkönnyebben hisztogramon tudjuk elérni.

```{r}
hist(vezik)
```

A hisztogramra alkalmazhatjuk azokat az argumentumokat, amiket a `par()` parancsban találhatok (help intenzív tanulmányozása javallott). A `col` itt az oszlopok színeit adja meg. Az ábra specifikus argumentumok az adott ábra készítő függvényben találhatók pl. a hisztogram esetén a `hist()` függvény `breaks` argumentuma, amiben megadhatjuk hány oszlopra tördelje a függvény az adatokat. A se túl sok, se túl kevés oszlop nem adja ki jól az adatok eloszlását, így megéri próbálgatni különböző értékekre!

```{r}
hist(vezik
     , col=rainbow(5)
     , breaks=5
     , xlab="Vezikula kerulet [nm]"
     , main= "Primer vezikulak TD_MPS1.3 sejtvonalbol"
     , las=1
     )

```

```{r}
hist(vezik
     , col=rainbow(5)
     , breaks=200
     , xlab="Vezikula kerulet [nm]"
     , main= "Primer vezikulak TD_MPS1.3 sejtvonalbol"
     , las=1
     )

```

Simított hisztogram:

```{r}
plot( density(vezik) )
```

Boxplot:
 Öt pontos ábrázolásnak is nevezik mert alapvetően öt értéket ábrázol

```{r boxplpot, echo = TRUE, include = TRUE, tidy = TRUE, eval = TRUE}
par(mfrow=c(2,2))
boxplot(beka$thossz, main= "Alap beállítás", cex.main = 0.7)
boxplot(beka$thossz,range = 0, main = "min-Q1-median-Q3-max", cex.main = 0.7)
boxplot(beka$thossz,range = 1, main = "(Q1-1*IQR)-Q1-median-Q3-(Q3+1*IQR)", cex.main = 0.7)
boxplot(beka$thossz,range = 1.5, main = "(Q1-1.5*IQR)-Q1-median-Q3-(Q3+1.5*IQR)", cex.main = 0.7)
par(mfrow=c(1,1))
```

Láthatók a kiugró adatok (körök), és látható az eloszlás ferdesége (medián helyzete alapján), elnyúltsága a \'\'szálkák\'\' alapján). Ez itt most eléggé szimmetrikus és nincs nagy elnyúlása.

Lehet csinosítgatni a `par()` függvényben található argumentumok megadásával / beállításával

```{r boxplpot2, echo = TRUE, include = TRUE, tidy = TRUE, eval = TRUE}
boxplot(beka$thossz, col = "red", las = 1)
```

Ez az ábrázolás arra nagyon jó hogy több csoportot össze lehessen hasonlítani, ekkor a tulajdonság és a csoportosító változó közé egy $\sim$ vonalat kell írni. Ez kb. annak felel meg, hogy azt mondjuk \'\'a \texttt{tomeg}  értéke függ a \texttt{faj} értékétől\'\' -- ezt a jelölést még sokszor fogjuk használni!

```{r boxplpot3, echo = TRUE, include = TRUE, tidy = TRUE, eval = TRUE}
boxplot(beka$tomeg ~ beka$faj, col = 2:4, las = 1, xlab = "", ylab = "Tömeg [g]")
```

Amit lehet látni, hogy a piros, és a kék viszonylag szimmetrikus, de a zöld ferdébb és elnyúltabb. 

### Barplot és hisztogram

Gyakran összekeverik ezt a két típust. Amit érdemes megjegyezni, hogy a hisztogram (részletesen előző fejezetben bemutatva) esetén az oszlopok összeérnek, ezzel is jelzik, hogy felosztottak egy folytonos intervallumot darabokra és ezeknek a rövidebb intervallumoknak az összesített gyakoriságát ábrázolják (*osztály gyakoriság*). Ellenben az oszlopdiagramoknál az oszlopok nem érnek össze, ezzel pedig azt mutatják, hogy ezek diszkrét kategóriák (*kategória gyakoriság*). Az oszlopdiagram értékei nem csak gyakoriságok lehetnek, hanem másfajta változók is. Legegyszerűbb a különbséget akkor megérteni, ha ábrázoljuk ugyanazt az adatot.

```{r}
par(mfrow=c(1,2))
hist(vezik, main="Hisztogram")
barplot(vezik, main="Barplot")
par(mfrow=c(1,1))
```

Míg a hisztogram kiszámította a belerakott adatoknak az **eloszlását**, a barplot csak sorra egymás után ábrázolta őket. Egy példa barplot helyes használatára:

```{r fig.cap="Barplot példa"}
barplot(c(CHF=322.45,EUR=340.17,USD=303.91,AUD=187.48,BGN=173.92,BRL=62.54,CAD=218.72,CNY=43.39), 
        main="Arfolyamok", ylab="HUF")
```

Diszkrét adatok adatok gyakoriságát `barplot()`-tal érdemes megjeleníteni. Azonban az adatokat előtte táblázatba kell gyűjteni, össze kell számolni a gyakoriságukat. Ezt a `table()` függvénnyel tudjuk megtenni.

```{r }
table(beka$faj)
barplot(table(beka$faj), las = 1, xlab = "", ylab = "Gyakoriság")
```

A hisztogram (`hist()` függvény) osztálygyakoriságokat ábrázol: egy adott intervallumba eső esetek gyakorisága (lásd korábban).

### Függvények rajzolása

Függvényeket a `curve()` paranccsal tudunk ábrázolni. Első argumentumaként egy **R** képletet kell megadni (nem idézőjelben!), melyben csak az *x* szerepel, mint változó. Alapértelmezettként 0 és 1 között ábrázol, így szükséges megadni az x tengely kiterjedését az `from` és `to` argumentumokkal. A `par()` argumentumai itt is használhatók.

```{r}
curve(x^2, xlim=c(-2,2))
```

### Kördiagram

Kördiagramot csak nagyon speciális esetekben alkalmazzunk, mert használata sokszor megtévesztő (nehezen becsülnek az emberek szögeket)!  

Ha mondjuk ábrázolni akarjuk a csőr adatbázisunk csőrhossz kategóriának arányát kördiagramon, akkor először is meg kell számolnunk hány egyed esik az egyes kategóriákba.

```{r}
table(csoradat$Csorhossz_kat)
```

Ezeket a számokat már ábrázolhatjuk.

```{r}
pie(table(csoradat$Csorhossz_kat))
```

A `plot()` és `par()` argumentumai közül most is legtöbb használható. Ami különleges: a `labels` argumentumban meghatározhatjuk a különböző kategóriákhoz írt címkéket, a `clockwise = TRUE`-val pedig megváltoztathatjuk a körcikkek irányát.

## Ábrázolás példák

Ez a fejezet csak példákat tartalmaz arra, hogy hogyan kell jó ábrákat készíteni.

```{r}
myfile = read.csv("EduMicrobialEnvironmentSE.csv", header=T, sep=",")

#View(myfile)
str(myfile)
table(myfile$Group2)
table(myfile$oxotol)
table(myfile$temprange)

```


### "UGLY" PLOTS

```{r}
barplot(table(myfile$Group2))

barplot(table(myfile$temprange))

hist(myfile$temp_opt.C.)
plot(density(myfile$temp_opt.C.))

boxplot(myfile$temp_opt.C.~myfile$oxotol)

plot(x=myfile$temp_opt.C.,y=myfile$Q)
plot(x=myfile$temp_opt.C.,y=log10(myfile$Genome_size))
plot(x=(myfile$bG+myfile$bC),y=myfile$A)
```

### NICE PLOTS

```{r}
par(mar=(c(bottom=4,left=10,top=4, right=4))) #margok beallitasa
barplot(table(myfile$Group2)
        , main="Taxonomic distribution"
        , xlab="Domain", ylab="Occurence"
        , col=rainbow(2)
        , cex.lab=2
        , cex.axis=1.5
        , cex.names=2
        )

par(mar=(c(bottom=4,left=5,top=4, right=4)))
barplot(table(myfile$temprange) 
        , main="Temperature range"
        , xlab="", ylab="Occurence"
        , col=c("red","green","blue", "orange")
        , cex.lab=2 
        , cex.axis=1.5
        , cex.names=2
        )

barplot(table(myfile$oxotol),main="Oxygen tolerance",
        xlab="",ylab="Occurence",
        col=rainbow(length(names(table(myfile$oxotol)))),
        cex.lab=2, cex.axis=1.5, cex.names=1.5
        )

par(mar=(c(bottom=4,left=5,top=4, right=4)))
hist(myfile$temp_opt.C.
        , main="Histogram of temperature optimum"
        , xlab="Temperature(°C)", ylab="Occurence"
        , col=c("red")
        , cex.lab=2
        , cex.axis=1.5
        , ylim=c(0,200)
     )

par(mar=(c(bottom=4,left=5,top=4, right=4)))
hist(myfile$pH_opt
     , main="pH optimum"
     , xlab="ph", ylab="Occurence"
     , col=c("green")
     , cex.lab=2
     , cex.axis=1.5
     , ylim=c(0,200)
     )

par(mar=(c(bottom=5,left=5,top=4, right=4)))
hist(myfile$pH_opt
     , main="Salt conc. optimum"
     , xlab="NaCl conc.[(w/V)%]",ylab="Occurence"
     , col=c("blue")
     , cex.lab=2
     , cex.axis=1.5
     , ylim=c(0,200)
     )


boxplot(myfile$temp_opt.C.~myfile$temprange,
        ylab="Temperature(°C)",
        col=c("red","green","blue", "orange"),
        cex.lab=2, cex.axis=1.5, cex.names=2)


boxplot(myfile$temp_opt.C.~myfile$Group2,
        xlab="Domain",ylab="Temperature(°C)",
        col=rainbow(2), cex.lab=2, cex.axis=1.5, cex.names=2)

boxplot(myfile$temp_opt.C.~myfile$oxotol,
        xlab="Domain",ylab="Temperature(°C)",
        col=rainbow(length(names(table(myfile$oxotol)))),
        cex.lab=2, cex.axis=1.5, cex.names=2)

par(mar=(c(bottom=5,left=5,top=5, right=5)))
plot(myfile$temp_opt.C., log10(myfile$Genome_size)
     , ylab="log10(Genome size)", xlab="Temperature(°C)"
     , col="purple"
     , cex.lab=2
     , cex.axis=1.5
     , pch=20
     , ylim=c(5.5,7.5), xlim=c(0,100)
     )

plot(myfile$temp_opt.C., myfile$bG+myfile$bC
     , ylab="GC-content", xlab="Temperature(°C)"
     , col="red", cex.lab=2, cex.axis=1.5,pch=1
     , ylim=c(0,1), xlim=c(0,100)
     )

plot(myfile$bG+myfile$bC, myfile$A
     , ylab="Alanine content of proteins", xlab="GC-content of the genome"
     , col="red" 
     , cex.lab=2
     , cex.axis=1.5
     ,pch=1
     , ylim=c(0,0.2), xlim=c(0.2,0.8)
     )

```

### 4DV4NC3D UB3RK1NG PL0TT1NG SK1LLZ EX.

```{r}
AA_ALL=myfile[,19:39]
Temp_ALL=myfile$temp_opt.C.
GC_ALL=myfile$bG+myfile$bC

# sajat szinskala letrehozasa RGB kodokkal
colorsch=c("#0F820F", "#C8C8C8","#A9A9A9","#0F820F", "#E60A0A",
           "#FA9600", "#0F820F","#145AFF","#145AFF", "#E60A0A",
           "#FA9600", "#DC9682","#00DCDC","#00DCDC", "#3232AA",
           "#3232AA", "#E6E600","#8282D2","#E6E600", "#B45AB4","#FF1493")

aalist=c("L","A","G","V",
         "E","S","I","K",
         "R","D","T","P",
         "N","Q","F","Y",
         "M","H","C","W","TER")

aalist=c("Leu","Ala","Gly","Val",
         "Glu","Ser","Ile","Lys",
         "Arg","Asp","Thr","Pro",
         "Asn","Gln","Phe","Tyr",
         "Met","His","Cys","Trp")  

par(mfrow = c(4,5), mar=c(4,5,1,1),bg="white",new=FALSE)
for (n in 1:20){#par(mar = c(4, 4, 4, 4) + 0.1) #PLOT
  plot(Temp_ALL,AA_ALL[,n],xlab = "Temperature (°C)", ylab = "Proportion",
       ylim = c(0,0.15),xlim=c(0,100),cex.lab=1.5,cex.axis=1.5,pch=".")
  legend("topright", legend = aalist[n], lwd = 0,cex=1.5,
         col = colorsch[n], ncol=1,
         pt.bg = colorsch[n], pch = 21, bty = "n")}

par(mfrow = c(4,5), mar=c(4,5,1,1),bg="white",new=FALSE)
for (n in 1:20){#par(mar = c(4, 4, 4, 4) + 0.1) #PLOT
  plot(GC_ALL,AA_ALL[,n],xlab = "GC-content", ylab = "Proportion",
       ylim = c(0,0.15),xlim=c(0,1),cex.lab=1.5,cex.axis=1.5,pch=".")
  legend("topright", legend = aalist[n], lwd = 0,cex=1.5,
         col = colorsch[n], ncol=1,
         pt.bg = colorsch[n], pch = 21, bty = "n")}

par(mfrow = c(1,1), mar=c(4,5,1,1),bg="white",new=FALSE)
```



<!-- 5. Ora meroszamok -->
```{r child="fejezetek/meroszamok.Rmd"}
```

<!-- 6. Ora konfidencia intervallumok -->
```{r child="fejezetek/konfint.Rmd"}
```


<!-- 7. Ora hipotezis vizsgalotak -->
```{r child="fejezetek/hipotvizsg.Rmd"}
```


<!-- Fuggelek -->
```{r child="fejezetek/fuggelek.Rmd"}
```
